# 功率控制模块 v0.1  by mc3545dada

## 内容
- 基于模型的功率预测
- 通过衰减输出值的功率抑制
- 基于error值和静态功率的功率分配
- 针对不同底盘构型设计的不同功率控制逻辑
- 附带的一些神奇小算法,滤波等

## 功能
- 用于简单测量单电机功率/底盘总功率
- 分配总功率并控制底盘总功率在限定值之内
- ......

## 如何使用

- 首先通过CMake等方式添加powerctrl.c/powerctrl.h文件于你的项目内
- 然后根据你的需求按照下面方式使用

### 1.只用于测量电机/底盘总功率
- 你需要获取想测量电机的 类型，电流，和速度 然后填入下面这个函数
- 对于类型，只拟合了DJI M3508和GM6020电机的模型，如果你需要测量其他电机功率或使用自己的参数，请自行拟合模型
- 类型的枚举量在powerctrl.h中已列出，以3508电机为例，则填入M3508_powermodel
- 第二和第三个参数要填入电流和速度，通常情况下直接填入电机反馈值即可(电流处也可填入欲发送电流来限制功率，详细见功率控制部分)
- (注意由于反馈电流和发送电流表现出的数值并非完全一致，所以不同情况下填入某种电流可能导致误差(比如填入反馈电流时 在底盘电机低负载高速度的时候会多预测5-10%的功率) 因此请根据你的目的来决定填入反馈电流还是控制电流)
- 第四个参数为是否启用负功率计算的选项，由于通常来说不需要考虑，所以不用填入(此选项.h中默认声明为E_disabled_negative）
```c++
    - cal_motor_power_by_model(E_Motor_PowerModel_Type motor_type ,double current, double speed,E_CalMotorPower_Negative_Status_Type Negative_Status)
```
- 之后创建一个double变量接收功率值即可
- 考虑到电流和速度突变导致的结果示数变化幅度大，如果功率仅作为观测用，你可以使用模块内自带的平均滑动滤波
- 例：
```c++
//初始化时创建一个名为powerFilter的滤波器,次数为500
//这个次数填的越大波越平滑，同时更新越慢
MovingAverageFilter powerFilter(500);
//然后在循环内持续更新他
//stable_power为你接收的滤波后的变量，update内为不断更新的待滤波的数据
stable_power_by_model = powerFilter.update(power_by_model);
```

### 2.用于限制底盘总功率/单电机功率
- 第一步使用下面函数分配功率
- 对于常规的四电机底盘模型,你需要先创建一个4个double大小的vector，在里面按顺序填上你的电机error值，然后把这个填入函数形参，再把总功率上限填入函数形参
- 之后创建一个4个double大小的vector，用于接收函数返回的分配好的四个电机功率，顺序和你填入的相同
- 此函数内部设置了 在给底盘限制比赛最低功率以上时的每个电机最低分配功率值，从而保证不会出现error过小导致电流无解进而超功率的情况，具体见下面说明
```c++
std::vector<double> power_allocation_by_error(std::vector<double>& motor_errors_vector, double total_power_limit)
```
- 然后使用下面这个函数来计算衰减系数
- （对于像DJI这类 输出电流和输入电流单位相同的 电机）
- 输入 想要发送的电流，这一时刻的速度，这个电机的最大分配功率(填入上面函数得出的每个电机分配到的功率)，返回一个计算后的衰减系数
- 注意一定是填入 欲发送的电流，这样才能起到限制功率的作用(发送电流不完全等于反馈电流)
- 用这个衰减系数乘输出电流(或者输出力矩等）后更新给电机就会使电机消耗的功率限制在你设定的功率下
```c++
double calculate_attenuation(E_Motor_PowerModel_Type motor_type, double desired_current, double current_speed, const double power_limit)
```
- 如果你想只限制单电机功率，可以跳过分配功率的函数 而直接使用第二个函数


### 3.注意
- 对于比赛来说 每一种底盘都需要在使用以上步骤后多进行一些调整
- 比如全向轮需要测量真实方向速度来补偿目标值从而保证小陀螺平移能走直线
- (因为你是对输出值直接衰减，所以会破坏运动学解算。当然也有其他办法比如反过来衰减一下速度，看你设计)
- 又如舵轮由于存在舵向电机和轮向电机，需要先把总功率分配给*舵组*和*轮组*，再对这两部分来分配四个电机功率
- 你可以简单针对你想应用构型写一下使用，后续我也可能会制作不同底盘的详细分配逻辑

## 对函数的相关说明(如果你是为了使用 可以不用看这一部分)
     double get_real_current(double current)
- 1. 获取真实(其实并不真实，是过单位换算的)电流（此处根据3508电机定义获取）
- 自2025.10.12之后的版本后，计算功率的模型函数和计算衰减系数的函数均在内部调用此函数
- 所以你可以在调用那两个函数时直接填入电机反馈的电流值
- 该函数仅用于优化模型时采样电流来显示的作用

- 2. 此处实际反馈电流不知道什么单位，按毫安估算所以除1000.0!!!!!不过貌似其实应该除819.2,但是我已经拟合完了
- 同样的，你在调用计算衰减系数函数时也要调用此函数或把想要发送的电流除1000.0！！！！！！！！！！！！！！
- 也就是在.h文件里宏定义的M_RealCurrent_Conversion这个


      double cal_motor_power_by_model(E_Motor_PowerModel_Type motor_type ,double current, double speed,E_CalMotorPower_Negative_Status_Type Negative_Status)
-  1. 功率预测模型函数的实现
-  在调用这个函数时填入电机电流（反馈电流和发送电流均可，单位一致）和电机反馈速度，接收得到的预测功率值
-  如果你想测出即将发送的功率来进行功率控制，请填入发送电流
-  反之，如果你只是想简单预测一下电机组消耗的功率，请填入反馈电流
-  注意：1.在负载很小且高速度时（比如底盘架起来让电机高速转）使用此模型可能会不准（表现为多预测5%-10%左右）推测这一点和模型采样未涉及有关
-    2.对于填入反馈电流和填入发送电流可能得到的功率不完全相同，因为反馈电流不完全等于发送电流

- 2. 正负功率使用：根据调用函数第四个参数来确定开启或关闭
- 对于绝对值:近似认为电机正反转所有参数高度对称，所以加上绝对值

```c++
std::vector<double> power_allocation_by_error(std::vector<double>& motor_errors_vector, double total_power_limit)
```
- 1. 基于电机pid的error值来分配功率
- 且在总error值较低时采取均分功率的策略
- 你需要先创建一个4个float大小的vector，在里面按顺序填上你的电机速度，然后把这个填入函数形参，再把总功率上限填入函数形参
- 之后创建一个4个double大小的vector，用于接收函数返回的分配好的四个电机功率，顺序和你填入的相同

- 2. 经测试 在根据error分配总功率的情况下 当小陀螺或速度剧烈变化时 给轮向电机发送的电流值剧烈变化，衰减系数无解，只能发送0电流
- 而即使发送0电流也会继续有功率产生（具体原因见calculate_attenuation函数的说明）
- 增加数值约功率上限的5%-10%占比,貌似总功率越大增加的数值占比越小
- 所以最好读取 裁判系统缓冲功率 或 超级电容功率 来进行功率闭环
- 如果没有以上操作可以选择牺牲一点功率上限换取稳定不超限（即下面define内的内容）
- 此选项通过在powerctrl.h中取消注释define来启用，同时也在那里更改SmallGyro_Power_Compensation_Alpha的值

- 3. 按比例分配功率
- 这里使用了calculate_attenuation函数中说明的第四种补偿方案，详细信息见那个函数和.h文件

```c++
double calculate_attenuation(E_Motor_PowerModel_Type motor_type, double desired_current, double current_speed, const double power_limit)
```
- 1. 计算衰减系数，输入 想要发送的电流，这一时刻的速度，这个电机的最大分配功率，返回一个计算后的衰减系数
- 用这个衰减系数乘输出电流后更新给电机就会使电机消耗的功率限制在你设定的功率下（以模型计算出来的功率为参照物）

- 2. 近似认为电机正反转所有参数高度对称，所以加上绝对值、

- 3. 未超上限不衰减（不包含负功率的情况，因为近似认定只要给他发送电流均为耗电电机,所以不使能正负）

- 4. 超上限了，则带入当前速度w，最大功率限制Pmax 于预测模型，解关于 I(衰减后) 的方程得到 I(衰减后)
- 再根据I衰减后 =衰减系数k * I原本想要发送值  解出衰减系数k，取值于0.0-1.0间

- 5. 判别式小于0，说明方程无解
- 如果方程无解，那么说明电流无论给什么值也不能在限定功率下正常工作（就是由于限定功率太小，导致电流给什么值都会超功率）
- 所以当根据error分配功率时，在轮组速度急剧变化（尤其是小陀螺平移的时候）某个电机被分配到了很小的功率 所以即使这个情况返回了0.0的衰减系数 使发送电流为0
- 那么还是会超功率的（电机空转时发送电流为0但由于有速度存在，还是会消耗功率）
- 有3种解决方法：1，在功率底盘总功率分配时少分配一点作为保险（比如比赛限定功率75w，那么只分配70w，这样会安全一点，但也有可能瞬间超）
- 2.根据超级电容或者底盘缓冲功率做一个闭环：如果检测到这两个功率短时间内大量消耗，那么就减小一点总限定功率
- 3.当检测到这种情况时 使出现问题的电机不采用error分配，强行把发送电流为0时的功率分配进去（我很建议这种方案和下面的方案）
- 4.和3类似，分配功率时 给每个轮子预留最小消耗功率 （从而防止分配时无视这部分功率而分配给别的电机导致最终超出这部分功率）
- 目前采用第四个方案，感觉效果较好

- 6. 没根和两个相同根很简单，如果两个不等根，优先取1,0内最大根
- 这种情况同样存在：当使用error分配时，在k1k2均不存在于0-1内的时候会超功率
- 具体原因和解决办法见上面判别式为0的注释


      #define M_RealCurrent_Conversion 1000.0
- 反馈或发送的电流除这个等于真实电流，其实这个应该是819.2的(反馈和发送都是819.2)但是由于我用1000.0拟合的模型所以这里是1000.0


      #define M_Too_Small_AllErrors 500.0
- 视为error较小时的总error参照值
- error小于大于这个值才会根据error分配功率，否则均分功率
- 此参数取决于你的pid参数，参考取自所有电机稳定状态下的最大error值之和，你的pid调的越好这个值越小


      #define M_SmallGyro_Power_Compensation_Alpha 0.05
- 小陀螺功率补偿(也可作为 为了稳定不超功率而衰减的 保险补偿)
- 关于是否开启此，见.c中std::vector<double> power_allocation_by_error函数内的说明
-  #define SmallGyro_Power_Compensation
- 补偿的比率，这个数越大 在小陀螺时功率限制的越稳定，但同时非小陀螺时功率利用率也越低
- 一般在0.05到0.10之间选择


      #define M_Motor_ReservedPower_Border 50.0_
- 为每个电机预留小部分功率的临界总功率值
- 总功率超过这个值就会为每个电机预留功率
- 正常情况下 为了稳定不超功率 将这个值设置为整场比赛可能会出现的最低功率来使用这个功能
- 当这个值过大的时候（150以上,超过比赛最大分配功率）则视为关闭这个功能


      #define M_PerMotor_ReservedPower 8.0
- 每个电机预留功率
- 据我测试这个值一般为8就已经能简单抑制由于快速变换速度导致的超功率问题了（虽然可能对于低功率时8还是有一点多）
- 这个值越大，在非频繁变换速度的情况下损失的功率越多 同时在频繁变换速度的情况下越稳定

